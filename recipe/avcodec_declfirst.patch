diff --git a/src/io/source_avcodec.c b/src/io/source_avcodec.c
index 45aa418..60193e8 100644
--- a/src/io/source_avcodec.c
+++ b/src/io/source_avcodec.c
@@ -109,6 +109,15 @@ uint_t aubio_source_avcodec_has_network_url(aubio_source_avcodec_t *s) {
 
 aubio_source_avcodec_t * new_aubio_source_avcodec(const char_t * path, uint_t samplerate, uint_t hop_size) {
   aubio_source_avcodec_t * s = AUBIO_NEW(aubio_source_avcodec_t);
+  AVFormatContext *avFormatCtx = s->avFormatCtx;
+  AVCodecContext *avCodecCtx = s->avCodecCtx;
+  AVFrame *avFrame = s->avFrame;
+  sint_t selected_stream = -1;
+#if FF_API_LAVF_AVCTX
+  AVCodecParameters *codecpar;
+#endif
+  AVCodec *codec;
+  uint_t i;
   int err;
   if (path == NULL) {
     AUBIO_ERR("source_avcodec: Aborted opening null path\n");
@@ -138,7 +147,6 @@ aubio_source_avcodec_t * new_aubio_source_avcodec(const char_t * path, uint_t sa
   }
 
   // try opening the file and get some info about it
-  AVFormatContext *avFormatCtx = s->avFormatCtx;
   avFormatCtx = NULL;
   if ( (err = avformat_open_input(&avFormatCtx, s->path, NULL, NULL) ) < 0 ) {
     char errorstr[256];
@@ -167,8 +175,6 @@ aubio_source_avcodec_t * new_aubio_source_avcodec(const char_t * path, uint_t sa
   //av_dump_format(avFormatCtx, 0, s->path, 0);
 
   // look for the first audio stream
-  uint_t i;
-  sint_t selected_stream = -1;
   for (i = 0; i < avFormatCtx->nb_streams; i++) {
 #if FF_API_LAVF_AVCTX
     if (avFormatCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
@@ -190,14 +196,13 @@ aubio_source_avcodec_t * new_aubio_source_avcodec(const char_t * path, uint_t sa
   //AUBIO_DBG("Taking stream %d in file %s\n", selected_stream, s->path);
   s->selected_stream = selected_stream;
 
-  AVCodecContext *avCodecCtx = s->avCodecCtx;
 #if FF_API_LAVF_AVCTX
-  AVCodecParameters *codecpar = avFormatCtx->streams[selected_stream]->codecpar;
+  codecpar = avFormatCtx->streams[selected_stream]->codecpar;
   if (codecpar == NULL) {
     AUBIO_ERR("source_avcodec: Could not find decoder for %s", s->path);
     goto beach;
   }
-  AVCodec *codec = avcodec_find_decoder(codecpar->codec_id);
+  codec = avcodec_find_decoder(codecpar->codec_id);
 
   /* Allocate a codec context for the decoder */
   avCodecCtx = avcodec_alloc_context3(codec);
@@ -208,7 +213,7 @@ aubio_source_avcodec_t * new_aubio_source_avcodec(const char_t * path, uint_t sa
   }
 #else
   avCodecCtx = avFormatCtx->streams[selected_stream]->codec;
-  AVCodec *codec = avcodec_find_decoder(avCodecCtx->codec_id);
+  codec = avcodec_find_decoder(avCodecCtx->codec_id);
 #endif
   if (codec == NULL) {
     AUBIO_ERR("source_avcodec: Could not find decoder for %s", s->path);
@@ -248,7 +253,6 @@ aubio_source_avcodec_t * new_aubio_source_avcodec(const char_t * path, uint_t sa
         s->input_samplerate, s->samplerate);
   }
 
-  AVFrame *avFrame = s->avFrame;
   avFrame = av_frame_alloc();
   if (!avFrame) {
     AUBIO_ERR("source_avcodec: Could not allocate frame for (%s)\n", s->path);
@@ -284,6 +288,7 @@ beach:
 void aubio_source_avcodec_reset_resampler(aubio_source_avcodec_t * s, uint_t multi) {
   // create or reset resampler to/from mono/multi-channel
   if ( (multi != s->multi) || (s->avr == NULL) ) {
+    int err;
     int64_t input_layout = av_get_default_channel_layout(s->input_channels);
     uint_t output_channels = multi ? s->input_channels : 1;
     int64_t output_layout = av_get_default_channel_layout(output_channels);
@@ -307,7 +312,6 @@ void aubio_source_avcodec_reset_resampler(aubio_source_avcodec_t * s, uint_t mul
 #endif
     // TODO: use planar?
     //av_opt_set_int(avr, "out_sample_fmt",     AV_SAMPLE_FMT_FLTP,      0);
-    int err;
 #ifdef HAVE_AVRESAMPLE
     if ( ( err = avresample_open(avr) ) < 0) {
 #elif defined(HAVE_SWRESAMPLE)
@@ -339,13 +343,26 @@ void aubio_source_avcodec_readframe(aubio_source_avcodec_t *s, uint_t * read_sam
   AVCodecContext *avCodecCtx = s->avCodecCtx;
   AVFrame *avFrame = s->avFrame;
   AVPacket avPacket = s->avPacket;
-  av_init_packet (&avPacket);
 #ifdef HAVE_AVRESAMPLE
   AVAudioResampleContext *avr = s->avr;
 #elif defined(HAVE_SWRESAMPLE)
   SwrContext *avr = s->avr;
 #endif /* HAVE_AVRESAMPLE || HAVE_SWRESAMPLE */
+  int got_frame = 0;
+  int ret = 0;
+#ifdef HAVE_AVRESAMPLE
+  int in_linesize = 0;
+  int in_samples = avFrame->nb_samples;
+  int out_linesize = 0;
+  int max_out_samples = AUBIO_AVCODEC_MAX_BUFFER_SIZE;
+  int out_samples = 0;
+#elif defined(HAVE_SWRESAMPLE)
+  int in_samples = avFrame->nb_samples;
+  int max_out_samples = AUBIO_AVCODEC_MAX_BUFFER_SIZE / avCodecCtx->channels;
+  int out_samples = 0;
+#endif /* HAVE_AVRESAMPLE || HAVE_SWRESAMPLE */
   smpl_t *output = s->output;
+  av_init_packet (&avPacket);
   *read_samples = 0;
 
   do
@@ -364,9 +381,8 @@ void aubio_source_avcodec_readframe(aubio_source_avcodec_t *s, uint_t * read_sam
     }
   } while (avPacket.stream_index != s->selected_stream);
 
-  int got_frame = 0;
 #if FF_API_LAVF_AVCTX
-  int ret = avcodec_send_packet(avCodecCtx, &avPacket);
+  ret = avcodec_send_packet(avCodecCtx, &avPacket);
   if (ret < 0 && ret != AVERROR_EOF) {
     AUBIO_ERR("source_avcodec: error when sending packet for %s\n", s->path);
     goto beach;
@@ -400,19 +416,19 @@ void aubio_source_avcodec_readframe(aubio_source_avcodec_t *s, uint_t * read_sam
   }
 
 #ifdef HAVE_AVRESAMPLE
-  int in_linesize = 0;
+  in_linesize = 0;
   av_samples_get_buffer_size(&in_linesize, avCodecCtx->channels,
       avFrame->nb_samples, avCodecCtx->sample_fmt, 1);
-  int in_samples = avFrame->nb_samples;
-  int out_linesize = 0;
-  int max_out_samples = AUBIO_AVCODEC_MAX_BUFFER_SIZE;
-  int out_samples = avresample_convert ( avr,
+  in_samples = avFrame->nb_samples;
+  out_linesize = 0;
+  max_out_samples = AUBIO_AVCODEC_MAX_BUFFER_SIZE;
+  out_samples = avresample_convert ( avr,
         (uint8_t **)&output, out_linesize, max_out_samples,
         (uint8_t **)avFrame->data, in_linesize, in_samples);
 #elif defined(HAVE_SWRESAMPLE)
-  int in_samples = avFrame->nb_samples;
-  int max_out_samples = AUBIO_AVCODEC_MAX_BUFFER_SIZE / avCodecCtx->channels;
-  int out_samples = swr_convert( avr,
+  in_samples = avFrame->nb_samples;
+  max_out_samples = AUBIO_AVCODEC_MAX_BUFFER_SIZE / avCodecCtx->channels;
+  out_samples = swr_convert( avr,
       (uint8_t **)&output, max_out_samples,
       (const uint8_t **)avFrame->data, in_samples);
 #endif /* HAVE_AVRESAMPLE || HAVE_SWRESAMPLE */
